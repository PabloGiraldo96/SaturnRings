<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width= , initial-scale=1.0">
	<title>Document</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.3/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.3/ScrollTrigger.min.js"></script>
<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three/build/three.module.js"
		}
	}
</script>
<link rel="stylesheet" href="/style.css">
</head>
<body>	


<script type="module"> 

import * as THREE from 'three';


//Manejo de scroll trigger con GSAP

gsap.registerPlugin(ScrollTrigger);


// Manejo de geometria, vertices del cubo 

const verticesOfCube = [
	-1,-1,-1,    1,-1,-1,    1, 1,-1,    -1, 1,-1,
	-1,-1, 1,    1,-1, 1,    1, 1, 1,    -1, 1, 1,
];

const indicesOfFaces = [
	2,1,0,    0,3,2,
	0,4,7,    7,3,0,
	0,1,5,    5,4,0,
	1,2,6,    6,5,1,
	2,3,7,    7,6,2,
	4,5,6,    6,7,4
];

// init

const camera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 0.01, 10 );
camera.position.z = 1;

const scene = new THREE.Scene();

const materialOne = new THREE.MeshMatcapMaterial();
const matcaptexture = new THREE.TextureLoader().load('img/casey-yau-as-tn-fotor-2023120625029.png');

materialOne.matcap = matcaptexture;

const firstGeometry = new THREE.SphereGeometry( 0.1, 15, 12);
const firstMaterial = new THREE.MeshMatcapMaterial();
const cube = new THREE.Mesh( firstGeometry, materialOne );

// RING MOVING 

const geometryOne = new THREE.TorusGeometry( 0.750, 0.033, 16, 80 );
const torus = new THREE.Mesh( geometryOne, firstMaterial );

const torusTwo = new THREE.TorusGeometry( 0.750, 0.033, 16, 80 );
const materialTwo = new THREE.MeshMatcapMaterial();
const torusTwO = new THREE.Mesh( torusTwo, firstMaterial );

//MATCAP TEXTURES

const rockMaterial = new THREE.MeshMatcapMaterial();
const matCapTextureDos = new THREE.TextureLoader().load("img/Rock034_PREVIEW-fotor-2023120624925.png")
rockMaterial.matcap = matCapTextureDos;


const fireMaterial = new THREE.MeshMatcapMaterial();
const matCapTextureTres = new THREE.TextureLoader().load("img/true-fotor-2023120624340.png")
fireMaterial.matcap = matCapTextureTres;

const waterMaterial = new THREE.MeshMatcapMaterial();
const matCapTextureCuatro = new THREE.TextureLoader().load("img/OIP-fotor-2023120624835.png")
waterMaterial.matcap = matCapTextureCuatro;

const voidMaterial = new THREE.MeshMatcapMaterial();
const matCapTextureCinco = new THREE.TextureLoader().load("img/R-fotor-2023120625125.png")
voidMaterial.matcap = matCapTextureCinco;

// CUBE
const spheric = new THREE.SphereGeometry( 0.045, 15, 12);
const material = new THREE.MeshMatcapMaterial();
const shpere = new THREE.Mesh( spheric, fireMaterial );

const geometry = new THREE.SphereGeometry( 0.09, 15, 12);
const mesh = new THREE.Mesh( geometry, waterMaterial );

const secondtGeometry = new THREE.SphereGeometry( 0.12, 15, 12);
const cubo = new THREE.Mesh( secondtGeometry, voidMaterial );

const thirdtGeometry = new THREE.SphereGeometry( 0.13, 15, 12);
const cubi = new THREE.Mesh( thirdtGeometry, rockMaterial );

const fourthGeometry = new THREE.SphereGeometry( 0.08, 15, 12);
const cuba = new THREE.Mesh( fourthGeometry, waterMaterial );

const fifthtGeometry = new THREE.SphereGeometry( 0.06, 15, 12);
const cubu = new THREE.Mesh( fifthtGeometry, materialOne );

const sixthtGeometry = new THREE.SphereGeometry( 0.4, 15, 12);
const cubew = new THREE.Mesh( sixthtGeometry, waterMaterial );

const seventhtGeometry = new THREE.SphereGeometry( 0.06, 15, 12);
const cubewn = new THREE.Mesh( seventhtGeometry, rockMaterial );

//const planeGeometry = new THREE.PlaneGeometry(20, 20);
//const planeMaterial = new THREE.MeshBasicMaterial({side: true, visible: false});
//		
//const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
//planeMesh.rotateX(-Math.PI / 2);
//
//
//
//const grid = new THREE.GridHelper(20, 20);

// SCENE OBJECTS 


scene.add( torus,torusTwO, cube, mesh,cubo,cubi,cuba,cubu, cubew, cubewn,shpere );

const renderer = new THREE.WebGLRenderer( { antialias: true } );

renderer.setSize( window.innerWidth, window.innerHeight );

document.body.appendChild( renderer.domElement );

  animate();

  function animate() {
    requestAnimationFrame(animate);
    animation();
  }


// Position

	cubewn.position.x = -0.8;
	cubewn.position.y = -0.39;
	cubew.position.x = 0.8;
	cubew.position.y = -0.4;
	cubu.position.x = -0.8;
	cubu.position.y = 0.35;
	cuba.position.x = -0.3;
	cuba.position.y = 0.4;
	torus.position.x = -0.1;
	torus.position.y = -0.3;
	torusTwO.position.x = 0.1;
	torusTwO.position.y = 0.3;
	mesh.position.x = -0.5;
	cube.position.x = 0;
	cube.position.y = -0.2;
	cubo.position.x = 0.3;
	cubo.position.y = 0.1;
	cubi.position.x = 0.6;
	cubi.position.y = 0.5;

// Animation with GSAP

gsap.globalTimeline.timeScale(0.5);


gsap.from(cuba.position, { duration: 1.9, opacity: 0, x:-800,  y: -550 });
gsap.from(cuba.position, { duration: 1.9, opacity: 0, x:-800,  y: -550 });
gsap.from(cube.position, { duration: 2.3, opacity: 0,  y: -450 });
gsap.from(cubi.position, { duration: 3.0, opacity: 0, x: Math.PI * 2, y: -1550});
gsap.from(cubo.position, { duration: 3.1, opacity: 0, x: 800, y: 250,  });
gsap.from(mesh.position, { duration: 3.6, opacity: 0,  y: -550 });
gsap.from(cubu.position, { duration: 3.8, opacity: 0, x: Math.PI * 2, y: 550 });
gsap.from(cubewn.position, { duration: 2.0, opacity: 0, y: -550 });
gsap.from(cubew.position, { duration: 2.5, opacity: 0, x: 550, y: 1550 });
gsap.from(torus.position, { duration: 4.5, opacity: 0, x: -2850});
gsap.from(torusTwO.position, { duration: 4.5, opacity: 0, x: 1850 });
gsap.from(shpere.rotation, { duration: 4, x: Math.PI * 2, y: Math.PI * 2, repeat: -1 });


setTimeout(() => {
    scene.background = new THREE.Color("#E9F1F7"); 
}, 8700);

//gsap.to(scene.background, { duration: 5, color: "#E9F1F7" });
  


//ScrollTrigger.create({
//  trigger: torus,  // Elemento de activaci贸n
//  start: "top 90%",  // Punto de inicio de la animaci贸n inversa
//  end: "bottom 50%",  // Punto de finalizaci贸n de la animaci贸n inversa
//  onEnter: () => gsap.to(torus.position, { duration: 2, opacity: 0, x: -200, y: -200, ease: "power2.out" }),
//  onLeaveBack: () => gsap.from(torus.position, { duration: 2, opacity: 0, x: -1150, y: -1550, ease: "power2.in" }),
//	markers: true,
//});
//


function animation(time){
//

cubewn.rotation.y = time / 1900;
cubewn.rotation.x = time / -1550;
cubew.rotation.y = time / 1900;
cubew.rotation.x = time / -1750;
cubu.rotation.y = time / 1900;
cubu.rotation.x = time / -2450;
cuba.rotation.y = time / 1900;
cuba.rotation.x = time / -2150;
torus.rotation.y = time / 2800;
torus.rotation.x = time / 3750;
torusTwO.rotation.y = time /-2800;
torusTwO.rotation.x = time / -3750;
mesh.rotation.y = time / -1900;
mesh.rotation.x = time / -1650;
cube.rotation.x = time / 1050;
cube.rotation.y = time / -1900;
cubo.rotation.x = time / 450;
cubo.rotation.y = time / -1900;
cubi.rotation.x = time / 950;
cubi.rotation.y = time / 1900;

mesh.setAnimationLoop = true;

renderer.render( scene, camera );


}

renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setAnimationLoop( animation );
document.body.appendChild( renderer.domElement );

	</script>

</body>
</html>